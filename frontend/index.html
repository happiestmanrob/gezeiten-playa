<script>
const TZ = "Atlantic/Canary";

function tLocal(iso) {
  try {
    return new Date(iso).toLocaleTimeString("de-DE", { 
      timeZone: TZ, 
      hour: "2-digit", 
      minute: "2-digit" 
    });
  } catch { 
    return "–"; 
  }
}

function tDate(iso) {
  return new Date(iso).toLocaleDateString("de-DE", {
    weekday: "long",
    day: "2-digit",
    month: "long",
    year: "numeric",
    timeZone: TZ
  });
}

function renderDay(j) {
  const dateEl = document.getElementById("dateLabel");
  const trendEl = document.getElementById("trend");
  const tb = document.getElementById("tbody");

  dateEl.textContent = tDate(j.meta.generatedAt);
  tb.innerHTML = "";

  (j.tides || []).forEach(e => {
    const badge = e.type === "High"
      ? "<span class='badge high'>Hochwasser</span>"
      : "<span class='badge low'>Niedrigwasser</span>";
    tb.innerHTML += `
      <tr>
        <td>${e.timeStr}</td>
        <td>${badge}</td>
        <td>${(e.height ?? 0).toFixed(2)}</td>
      </tr>`;
  });

  // --- Trend korrekt bestimmen ---
  const nowCanary = new Date(new Date().toLocaleString("en-US", { timeZone: TZ }));

  // Nur zukünftige Gezeiten
  const futureTides = j.tides.filter(t => new Date(t.iso) > nowCanary);
  const pastTides = j.tides.filter(t => new Date(t.iso) <= nowCanary);

  const next = futureTides.length ? futureTides[0] : null;
  const prev = pastTides.length ? pastTides[pastTides.length - 1] : null;

  let trendTxt = "–";
  let trendClass = "";

  if (next && prev) {
    // Wenn letztes Ereignis schon länger als 30 Min her ist → auf das nächste schauen
    const diffMin = (nowCanary - new Date(prev.iso)) / 60000;
    const rising = next.type === "High";
    const falling = next.type === "Low";

    if (rising && diffMin >= 0) {
      trendTxt = `Das Wasser steigt<br><span style="font-size:0.95em;">(nächstes Hochwasser um ${next.timeStr} Uhr)</span>`;
      trendClass = "trend-rise";
    } else if (falling && diffMin >= 0) {
      trendTxt = `Das Wasser fällt<br><span style="font-size:0.95em;">(nächstes Niedrigwasser um ${next.timeStr} Uhr)</span>`;
      trendClass = "trend-fall";
    }
  } 
  else if (next) {
    // Nur ein zukünftiges Ereignis vorhanden
    if (next.type === "High") {
      trendTxt = `Das Wasser steigt<br><span style="font-size:0.95em;">(nächstes Hochwasser um ${next.timeStr} Uhr)</span>`;
      trendClass = "trend-rise";
    } else {
      trendTxt = `Das Wasser fällt<br><span style="font-size:0.95em;">(nächstes Niedrigwasser um ${next.timeStr} Uhr)</span>`;
      trendClass = "trend-fall";
    }
  }

  trendEl.innerHTML = trendTxt;
  trendEl.className = trendClass;

  document.getElementById("source").textContent =
    `Quelle: tide-forecast.com (geparst) · Aktualisiert ${new Date(j.meta.generatedAt).toLocaleString("de-DE", { timeZone: TZ })}`;
}

async function loadDay(offset = 0) {
  try {
    const res = await fetch(`data.json?cb=${Date.now()}`);
    const j = await res.json();
    renderDay(j);
  } catch (e) {
    document.getElementById("tbody").innerHTML = `<tr><td colspan="3">Fehler: ${e.message}</td></tr>`;
  }
}

loadDay();
</script>
